# async def ask_for_reward(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     """
#     When a user sends any text in a group, prompt them to allocate a TON reward via a popup.
#     """

#     keyboard = [
#         [InlineKeyboardButton("Allocate TON reward", callback_data="allocate_ton")]
#     ]
#     reply_markup = InlineKeyboardMarkup(keyboard)
#     await update.message.reply_text(
#         "You called the bot! Allocate a TON reward:", reply_markup=reply_markup
#     )


# async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     """
#     Handle button press and show a popup alert to the user.
#     """
#     logger.info()
#     query = update.callback_query
#     await query.answer(text="TON reward allocated!", show_alert=True)


# async def debug_update(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     logger.info(
#         f"DEBUG UPDATE received: chat_type={getattr(update.effective_chat, 'type', None)}, update={update}"
#     )


import os
import time
import asyncio
from dotenv import find_dotenv, load_dotenv
from agent import generate_tweet, generate_quiz
import logging
import re  # Add re import

# Telegram bot imports
from telegram import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Update,
    WebAppInfo,
    KeyboardButton,
    ReplyKeyboardMarkup,
)
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    CallbackQueryHandler,
    MessageHandler,
    filters,
    CallbackContext,
    ConversationHandler,  # Added ConversationHandler
    PollAnswerHandler,  # Added PollAnswerHandler
)
import uuid  # For generating unique payment IDs

BOT_USERNAME = "@gamer_maze_bot"

# Configure logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv(find_dotenv())

# Telegram bot token
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
if not TELEGRAM_TOKEN:
    raise ValueError("No TELEGRAM_TOKEN found in .env file")

# Game creation conversation states
CHOOSE_GAME_TYPE, ENTER_REWARDS, CONFIRM_DEPOSIT, CREATE_GAME_TOPIC = range(4)


async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Hello! I'm your bot. How can I assist you today?")


async def help(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = """
🤖 *Mental Maze Bot Commands* 🤖

/start - Start the bot
/help - Show this help message
/creategame - Create a new quiz game (free or with TON rewards)
/checkwins - Check your reward game winners and distribute prizes
/cancel - Cancel the current game creation process

You can also simply send any topic to generate a quick quiz!

*TON Rewards Feature*:
When creating a reward game, you can offer TON cryptocurrency as prizes for winners. Winners are tracked automatically based on who answers correctly first.
    """
    await update.message.reply_text(help_text, parse_mode="Markdown")


def parse_quiz(quiz_text: str) -> dict | None:
    """Parses the quiz text generated by the agent into a dictionary."""
    question_match = re.search(r"Question: (.*)", quiz_text)
    options_match = re.findall(r"[A-D]\) (.*)", quiz_text)
    correct_answer_match = re.search(r"Correct Answer: ([A-D])", quiz_text)

    if question_match and len(options_match) == 4 and correct_answer_match:
        question = question_match.group(1).strip()
        options = [opt.strip() for opt in options_match]
        correct_letter = correct_answer_match.group(1)
        correct_option_index = ord(correct_letter) - ord(
            "A"
        )  # Convert 'A'->0, 'B'->1, etc.

        return {
            "question": question,
            "options": options,
            "correct_option_id": correct_option_index,
        }
    else:
        logger.error(f"Failed to parse quiz text: {quiz_text}")
        return None


async def handle_response(text: str):
    processed_text = text.lower().strip()

    # Check if the request is for multiple quizzes
    multiple_request_keywords = ["three question", "multiple question", "several quiz"]
    is_multiple_request = any(
        keyword in processed_text.lower() for keyword in multiple_request_keywords
    )

    if not processed_text:
        return "Please provide a valid topic for quiz generation."

    if is_multiple_request:
        # Extract the main topic
        topic = (
            processed_text.split("about")[1].split(".")[0].strip()
            if "about" in processed_text
            else processed_text
        )
        return f"I noticed you want multiple quizzes about '{topic}'. Please send separate requests for each quiz you'd like to create."

    # Regular single quiz handling
    quiz_text = await generate_quiz(processed_text)

    # Check if we got an error message back from the generator
    if quiz_text.startswith("Sorry,") or quiz_text.startswith("An error"):
        return quiz_text

    parsed_quiz = parse_quiz(quiz_text)
    if parsed_quiz:
        return parsed_quiz
    else:
        return "Sorry, I couldn't generate a valid quiz poll for that topic. Try again?"


async def process_and_respond(
    update: Update, context: ContextTypes.DEFAULT_TYPE, text: str, processing_message
):
    """Handle time-consuming operations in the background"""
    chat_id = update.message.chat_id

    try:
        # Process the request (potentially slow operation)
        response_data = await handle_response(text)

        # Delete or update the processing message
        try:
            await processing_message.delete()
        except Exception:
            # If deletion fails, try to edit instead
            try:
                await processing_message.edit_text("✅ Quiz ready!")
            except Exception:
                pass  # If both fail, just continue

        # Send the actual response
        if isinstance(response_data, dict):
            # Send as a poll
            await context.bot.send_poll(
                chat_id=chat_id,
                question=response_data["question"],
                options=response_data["options"],
                type="quiz",
                correct_option_id=response_data["correct_option_id"],
                is_anonymous=False,
            )
        elif isinstance(response_data, str):
            # Send as a text message
            await context.bot.send_message(chat_id=chat_id, text=response_data)
    except Exception as e:
        # Handle errors
        logger.error(f"Error processing response: {e}")
        try:
            await processing_message.edit_text(
                "Sorry, I encountered an error while processing your request. Please try again with a simpler query."
            )
        except Exception:
            # If editing fails, try sending a new message
            try:
                await context.bot.send_message(
                    chat_id=chat_id,
                    text="Sorry, I encountered an error while processing your request. Please try again with a simpler query.",
                )
            except Exception:
                pass  # If both fail, just continue


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message_type = update.message.chat.type
    text = update.message.text
    chat_id = update.message.chat_id  # Get chat_id

    print(f"Received message: {text} in chat type: {message_type} from user {chat_id}")
    response_data: dict | str

    if message_type == "group" or message_type == "supergroup":
        if BOT_USERNAME in text:
            # Handle group message - first send acknowledgment
            processing_message = await update.message.reply_text(
                "🧠 Processing your request... This may take a moment."
            )

            # Then process in the background
            new_text = text.replace(BOT_USERNAME, "").strip()
            context.application.create_task(
                process_and_respond(update, context, new_text, processing_message)
            )
        return
    else:
        # For private messages, send acknowledgment first
        processing_message = await update.message.reply_text(
            "🧠 Generating quiz... This may take a moment."
        )

        # Then process in the background
        context.application.create_task(
            process_and_respond(update, context, text, processing_message)
        )


async def generate_quiz_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # This command might need adjustment if you want it to send a poll too
    # For now, it still just prints the raw quiz text
    quiz = await generate_quiz("Python programming")
    print(quiz)
    logger.info(quiz)
    await update.message.reply_text(
        f"Generated quiz text:\n{quiz}"
    )  # Keep as text for now or adapt


async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Log Errors caused by Updates."""
    print(f"Update {update} caused error {context.error}")


# --- Game Creation Conversation Functions ---


async def start_game_creation(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> int:
    """Starts the game creation conversation."""
    keyboard = [
        [
            InlineKeyboardButton("🏆 Reward Game", callback_data="reward"),
            InlineKeyboardButton("🆓 Free Game", callback_data="free"),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "Let's create a new quiz game! Should it be a free game or have TON rewards?",
        reply_markup=reply_markup,
    )
    return CHOOSE_GAME_TYPE


async def choose_game_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handles the choice between free and reward game."""
    query = update.callback_query
    await query.answer()
    game_type = query.data
    context.user_data["game_type"] = game_type  # Store the choice

    if game_type == "reward":
        await query.edit_message_text(
            text="Okay, a reward game! Please enter the TON rewards for the winners.\n"
            "Example: `1st: 2 TON, 2nd: 1 TON, 3rd: 0.5 TON`"
        )
        return ENTER_REWARDS
    else:
        await query.edit_message_text(
            text="Okay, a free game it is! Now, what topic should the quiz be about?"
        )
        return CREATE_GAME_TOPIC  # Skip reward steps for free game


async def enter_rewards(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handles receiving the reward amounts."""
    rewards_text = update.message.text
    context.user_data["rewards_text"] = rewards_text  # Store raw text for now

    # Parse rewards (simplified)
    try:
        # Real implementation would do proper parsing here
        total_reward = 3.5  # Placeholder calculation, would parse from rewards_text
        context.user_data["total_reward"] = total_reward

        # Generate a unique payment ID for this transaction
        payment_id = str(uuid.uuid4())
        context.user_data["payment_id"] = payment_id

        # Create a button that opens the TON Connect Mini App
        ton_app_url = f"https://your-ton-connect-app.com?paymentId={payment_id}&amount={total_reward}"

        keyboard = [
            [
                KeyboardButton(
                    "💎 Pay with TON Wallet", web_app=WebAppInfo(url=ton_app_url)
                )
            ],
            [KeyboardButton("📝 Manual Confirmation")],
        ]
        reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True)

        await update.message.reply_text(
            f"Ready to create a game with these rewards:\n{rewards_text}\n\n"
            f"Total: {total_reward} TON\n\n"
            f"Click the button below to connect your TON wallet and make the payment.\n"
            f"Or use 'Manual Confirmation' after sending TON manually.",
            reply_markup=reply_markup,
        )

        return CONFIRM_DEPOSIT

    except Exception as e:
        logger.error(f"Error parsing rewards: {e}")
        await update.message.reply_text(
            "Sorry, I couldn't understand that format. Please use format like:\n"
            "`1st: 2 TON, 2nd: 1 TON, 3rd: 0.5 TON`"
        )
        return ENTER_REWARDS


async def confirm_deposit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handles the deposit confirmation."""
    confirmation = update.message.text
    if (
        confirmation.strip().upper() == "CONFIRMED"
        or confirmation == "📝 Manual Confirmation"
    ):
        # TODO: Add blockchain confirmation check here
        # In a real implementation, you would verify the transaction

        await update.message.reply_text(
            "Deposit confirmed! Now, what topic should the quiz be about?"
        )
        return CREATE_GAME_TOPIC
    else:
        await update.message.reply_text(
            "Please type 'CONFIRMED' after making the deposit."
        )
        return CONFIRM_DEPOSIT  # Stay in this state


async def create_game_topic(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Gets the topic and creates the game poll."""
    topic = update.message.text
    chat_id = update.message.chat_id
    game_type = context.user_data.get("game_type", "free")
    rewards_text = context.user_data.get("rewards_text", "None")

    # Send processing message
    processing_message = await update.message.reply_text(
        f"Creating a {game_type} quiz about '{topic}'..."
    )

    # Process in the background to avoid timeouts
    try:
        # Generate quiz
        quiz_text = await asyncio.wait_for(generate_quiz(topic), timeout=10.0)
        parsed_quiz = parse_quiz(quiz_text)

        if parsed_quiz:
            # Add game info to the question if needed
            question_prefix = (
                f"🏆 Reward Game! ({rewards_text})\n\n"
                if game_type == "reward"
                else "🆓 Free Game!\n\n"
            )
            question = question_prefix + parsed_quiz["question"]

            # Send the quiz poll
            poll = await context.bot.send_poll(
                chat_id=chat_id,
                question=question,
                options=parsed_quiz["options"],
                type="quiz",
                correct_option_id=parsed_quiz["correct_option_id"],
                is_anonymous=False,
            )

            # Store poll details for reward tracking
            if game_type == "reward":
                # In a real implementation, you'd save this to a database
                context.bot_data.setdefault("reward_games", {})
                context.bot_data["reward_games"][poll.poll.id] = {
                    "rewards": rewards_text,
                    "total_reward": context.user_data.get("total_reward", 0),
                    "creator": update.effective_user.id,
                    "correct_answer": parsed_quiz["correct_option_id"],
                    "winners": [],
                }
                logger.info(f"Created reward game with ID {poll.poll.id}")
        else:
            # Error handling
            await update.message.reply_text(
                f"Failed to create a valid quiz. Please try another topic."
            )

    except asyncio.TimeoutError:
        await update.message.reply_text(
            "Quiz generation took too long. Please try a simpler topic."
        )
    except Exception as e:
        logger.error(f"Error creating game: {e}")
        await update.message.reply_text(
            f"An error occurred while creating the game. Please try again."
        )

    finally:
        # Delete processing message
        try:
            await processing_message.delete()
        except Exception:
            pass

    # Clean up user data for this conversation
    context.user_data.clear()
    return ConversationHandler.END


async def cancel_creation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancels the game creation process."""
    await update.message.reply_text("Game creation cancelled.")
    context.user_data.clear()
    return ConversationHandler.END


async def handle_poll_answer(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> None:
    """Handle when users answer polls, particularly for reward games."""
    answer = update.poll_answer
    poll_id = answer.poll_id
    selected_option = answer.option_ids[0] if answer.option_ids else None
    user_id = answer.user.id if answer.user else None

    # Check if this poll is a reward game
    if poll_id in context.bot_data.get("reward_games", {}):
        game_data = context.bot_data["reward_games"][poll_id]
        correct_answer = game_data["correct_answer"]

        # Check if user answered correctly
        if selected_option == correct_answer:
            user = answer.user
            user_info = (
                f"{user.first_name} ({user.username})"
                if user.username
                else user.first_name
            )

            # Add to winners list if not already there
            if user_id not in [u["id"] for u in game_data["winners"]]:
                game_data["winners"].append(
                    {
                        "id": user_id,
                        "name": user_info,
                        "time": time.time(),  # Record time of answer for sorting winners
                    }
                )
                logger.info(
                    f"User {user_info} answered correctly and added to winners for game {poll_id}"
                )

                # Sort winners by time
                game_data["winners"].sort(key=lambda x: x["time"])

                # In a real implementation, you would:
                # 1. Notify creator about winners
                # 2. Handle TON distributions when the poll ends
                # This requires TON SDK integration and secure wallet handling


async def check_wins_command(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> None:
    """Command to check game results and distribute rewards."""
    user_id = update.effective_user.id
    reward_games = context.bot_data.get("reward_games", {})

    # Find games created by this user
    user_games = {}
    for poll_id, game_data in reward_games.items():
        if game_data.get("creator") == user_id:
            user_games[poll_id] = game_data

    if not user_games:
        await update.message.reply_text("You haven't created any reward games yet.")
        return

    # For each game, report winners
    response = "🏆 Your Reward Games:\n\n"
    for poll_id, game_data in user_games.items():
        winners = game_data.get("winners", [])
        rewards = game_data.get("rewards", "Not specified")

        response += f"Game ID: {poll_id}\n"
        response += f"Rewards: {rewards}\n"

        if not winners:
            response += "No winners yet.\n\n"
            continue

        response += "Winners:\n"
        for i, winner in enumerate(winners[:3]):  # Show top 3 winners
            rank = ["🥇 First", "🥈 Second", "🥉 Third"][i] if i < 3 else f"{i+1}th"
            response += f"{rank}: {winner['name']}\n"

        # In a real implementation, you would add buttons to:
        # 1. Distribute rewards
        # 2. Close the game
        # 3. View full list of winners
        response += "\n"

    # Add a note about TON wallet
    response += (
        "\nTo distribute rewards, you would need to integrate with TON wallet SDK.\n"
    )
    response += (
        "This would require secure key management and wallet creation for winners."
    )

    await update.message.reply_text(response)


# --- End Game Creation Functions ---


if __name__ == "__main__":
    print("Starting bot...")
    # Create the application and pass it your bot's token
    app = Application.builder().token(TELEGRAM_TOKEN).build()

    # Add conversation handler for game creation
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("creategame", start_game_creation)],
        states={
            CHOOSE_GAME_TYPE: [CallbackQueryHandler(choose_game_type)],
            ENTER_REWARDS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, enter_rewards)
            ],
            CONFIRM_DEPOSIT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, confirm_deposit)
            ],
            CREATE_GAME_TOPIC: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, create_game_topic)
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel_creation)],
    )
    app.add_handler(conv_handler)

    # Add standard command handlers
    app.add_handler(CommandHandler("start", start_command))
    app.add_handler(CommandHandler("help", help))
    app.add_handler(CommandHandler("checkwins", check_wins_command))

    # Add poll answer handler for tracking winners
    app.add_handler(PollAnswerHandler(handle_poll_answer))

    # Message handler for general quiz requests
    # Make sure this runs after the conversation handler
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # error handler
    app.add_error_handler(error_handler)

    print("Bot started...")
    app.run_polling(3)
